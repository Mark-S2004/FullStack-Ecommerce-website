import { HttpException } from '@exceptions/HttpException';
import orderModel from '@models/order.model';
import stripe from '../utils/stripe';
import { calcShipping, calcTax } from '../utils/orderCalculations';
import { User } from '@interfaces/users.interface'; // Assuming User interface is correct now
import productModel from '@/models/products.model';
import { OrderItem } from '@interfaces/orders.interface'; // Import OrderItem interface

// Assuming the input `cart` is the populated cart from the user model
export const create = async (userId: string, userCart: User['cart'], shippingAddress: any) => {
  if (!userCart || userCart.length === 0) {
    throw new HttpException(400, 'Cart is empty');
  }

  // Recalculate totals on the server side based on current product prices/stock
  // Fetch fresh product data to ensure price/stock is accurate
  const productDetails = await Promise.all(
    userCart.map(async (item) => {
      const product = await productModel.findById(item.product); // item.product should be an ObjectId here
      if (!product) throw new HttpException(404, `Product not found: ${item.product}`);
      // Ensure stock is sufficient
      if (product.stock < item.qty) {
        throw new HttpException(400, `Not enough stock for ${product.name}. Available: ${product.stock}`);
      }
      // Decrement stock *before* creating order (or handle this post-payment)
      // Note: A more robust flow would reserve stock or decrement only on payment confirmation.
      // For simplicity based on the provided code, we'll decrement now.
       product.stock -= item.qty;
       await product.save();
      return { product, item };
    })
  );

  const subtotal = productDetails.reduce((sum, { product, item }) => sum + product.price * item.qty, 0);

  // Assuming country is part of the shippingAddress
  const country = shippingAddress.country || 'US'; // Default to US if not provided
  const shippingCost = calcShipping(country, userCart as any[]); // Pass cart items to shipping calc
  const tax = calcTax(subtotal);
  const total = subtotal + shippingCost + tax;

  // Create the order in your database first
  const order = await orderModel.create({
    user: userId,
    items: userCart, // Store the cart items as they were
    shippingAddress: shippingAddress, // Store the shipping address object
    shippingCost,
    tax,
    total,
    status: 'Pending', // Initial status
    // Order number generated by the pre-save hook
  });

  // Create Stripe Checkout session
  const session = await stripe.checkout.sessions.create({
    payment_method_types: ['card'],
    mode: 'payment',
    line_items: productDetails.map(({ product, item }) => ({
      price_data: {
        currency: 'usd',
        product_data: {
          name: product.name,
          images: product.images, // Include product images
        },
        unit_amount: Math.round(product.price * 100), // Price in cents
      },
      quantity: item.qty,
    })),
     // Include shipping cost as a line item (optional, but common)
     shipping_options: [{
        shipping_amount: Math.round(shippingCost * 100), // Shipping in cents
        shipping_address_collection: { allowed_countries: [country] }, // Limit shipping countries
        // You might want a more sophisticated shipping setup in a real app
         tax_behavior: 'inclusive', // Or 'exclusive' depending on your tax setup
         type: 'fixed_amount',
         display_name: 'Standard Shipping'
     }],
     // Add tax rate logic if you have different rates or need to specify tax_id
     // For a simple flat tax calculated manually, it might just be included in the total price or handled via tax_behavior

    success_url: `${process.env.CLIENT_URL}/checkout-success?orderId=${order._id}`,
    cancel_url: `${process.env.CLIENT_URL}/checkout-cancel`,
    metadata: {
      orderId: order._id.toString(), // Store the order ID for webhook
      userId: userId.toString(), // Also store user ID
    },
     // Allow promo codes if you have them set up in Stripe
     allow_promotion_codes: true,
  });

   // Important: Clear the user's cart only *after* the order is successfully created in the DB and before redirecting to Stripe
   // Clearing here ensures the cart is empty if the user completes the Stripe payment.
   // If the user cancels the Stripe payment, the stock decrement might need to be rolled back.
   // A more robust system might handle stock updates upon webhook receipt.
   // For this fix, we'll clear the cart here and decrement stock immediately.
   // await clearUserCart(userId); // Clear cart is now handled in the controller after session creation


  return { order, sessionUrl: session.url };
};

// Updated to fetch populated orders for display (e.g., in admin or profile)
export const findAllOrders = async (): Promise<Order[]> => {
  // Populate user name and product names for easier display
  return await orderModel.find().populate('user', 'name').populate('items.product', 'name price images');
};

// Updated to fetch populated orders for a specific customer
export const findOrdersByCustomer = async (customerId: string): Promise<Order[]> => {
   // Validate customerId format
    if (!Types.ObjectId.isValid(customerId)) {
       throw new HttpException(400, 'Invalid customer ID format');
    }
  // Populate product names within order items
  return await orderModel.find({ user: customerId }).populate('items.product', 'name price');
};

export const updateOrderStatus = async (orderId: string, status: Order['status']): Promise<Order> => { // Use Order['status'] for type safety
  // Validate orderId format
   if (!Types.ObjectId.isValid(orderId)) {
       throw new HttpException(400, 'Invalid order ID format');
    }

  const order = await orderModel.findByIdAndUpdate(orderId, { status }, { new: true, runValidators: true }); // Added runValidators
  if (!order) throw new HttpException(404, 'Order not found');
  return order;
};